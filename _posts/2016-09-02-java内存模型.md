---
title: 2016-09-02-java内存模型
date: 2016-09-02 20:55:52
---
java内存模型规定了如何和何时可以看到其他线程修改的共享变量的值，以及在必须时如何同步的访问共享变量的值。

#### Java内存模型：

1）主要目标是定义程序中变量（指共享变量，存在竞争的变量）的访问规则，就是在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。

2）规定所有的变量都存储在**主内存**中，而每条线程还有自己的**工作内存**，线程的工作内存保存了该线程使用到的变量的主内存中的副本，线程对变量的所有操作都是在工作内存中完成的，而不能直接读写主内存中的变量（volatile变量依然有共享内存的拷贝，但是从工作内存读写数据前，必须先将主内存的数据同步到工作内存中）。

3）不同线程之间也无法访问到对方工作内存中的变量，线程间值得传递都需要通过主内存来完成。

![](http://i1.piimg.com/595056/4458397ff423b748.jpg)
![](http://i1.piimg.com/595056/c69dd909545de609.jpg)

Java内存模型往往是指Java虚拟机的运行时内存模型，它规定和指引Java程序在不同的内存架构、cpu和操作系统间有确定性的行为；Java内存模型对一个线程所做的变动能被其他线程可见提供了保证，它们之间是先行发生关系，这种关系确保了：

1）线程内的代码能够按先后顺序执行，这被称为**程序次序规则**（一个线程内保证语义的串行性）

有序性---在并发时，程序的执行可能就会出现乱序（例读写线程：a=1; flag=true）

**乱序 why?** 这个要从cpu指令说起，Java中的代码编译以后，最后也是转换为汇编码的，一条指令的执行是可以分为很多步骤的（取指--译码--执行--写回），当并发时多条指令是一种相对错开的方式并行执行，所以就可能出现乱序执行。。而由于指令间数据相互依赖造成指令等待，从而产生空闲时间，需要改变指令顺序以提高执行效率---也就是Java内存模型的指令重排，使流水线更加顺畅，当然不能破坏串行程序的语义（可以使用volatile关键字避免优化产生的此类问题）

指令重排序的意义：能够根据不同处理器的特性（cpu的多级缓存系统，多核处理器）适当的重新排序机器指令，使机器指令更符合cpu的执行特点，最大限度的发挥机器的性能。

2）对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做**管程锁定规则**

3）前一个对volatile的写操作在后一个volatile的读操作之前，也叫**volatile变量规则**

4）一个线程内的任何操作必须在这个线程的start（）调用之后，也叫做**线程启动规则**

5）一个线程的所有操作都会在线程终止之前，**线程终止规则**

6）一个对象的终结操作必须在这个对象构造完成之后，**对象终结规则**

**Notice**：volatile是一个特殊的修饰符，只有成员变量才能使用它，特性：

1）在Java并发程序缺少同步类的情况下，多线程对被volatile修饰的成员变量的操作对其他线程是透明的，原因是volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。

2）volatile变量可以禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中所有依赖的赋值结果都能获得正确结果，而不能保证变量赋值操作顺序和实际执行的顺序一致。