---
title: JVM内存管理--GC
date: 2016-07-10 22:50:11
---
官方解释：Java虚拟机具有一个堆Heap，堆是运行时数据区域，所有类实例和和数组的内存均从此分配。

JVM主要管理两类内存：

堆---是在Java虚拟机启动时创建，Java代码可及的内存，留给开发人员使用--即存放java对象。

非堆内存---是JVM留给自己用的，包含方法区（用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，在类加载器加载class文件到内存中的时候，JVM会提取其中的类信息，并将这些类信息放到方法区中），JVM内部处理或优化所需的内存、类结构（如运行时常数池，字段和方法数据）以及方法和构造方法的代码---即存放类加载信息。

在程序运行期间如果想进行垃圾回收，就必须让GC线程与程序当中的线程互相配合，才能在不影响程序运行的前提下，顺利的将垃圾进行回收。

### GC策略要解决的问题：
#### 1、哪些对象可以被回收
引用计数算法---效率高，但对于循环引用的对象无法进行回收

根搜索算法---jvm普遍采用的算法，原理是设立若干种根对象，当任何一个根对象到某一个对象不可达时，则认为该对象是可以被回收的。

可以当作GC roots的对象有以下几种：

a、虚拟机栈中的引用的对象

b、方法区中的类静态属性引用的对象

c、方法区中的常量引用的对象，主要指的是声明为final的常量值

d、本地方法栈中JNI的引用的对象

a和d都是指的方法的本地变量表

#### 2、什么时候回收这些对象
概括的说触发主GC的条件：a、当应用程序空闲时，即没有应用程序在运行时，GC会被调用 b、Java堆内存不足时，GC也会被调用。

首先明确一点，GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。

2.1、对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次MinorGC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。

2.2、Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生FullGC，并且一般都会伴随有MinorGC。大对象直接进入老年代，如很长的字符串，虚拟机提供一个参数，令大于这个参数值得对象直接在老年代中分配，避免在Eden区和Survivor区发生大量的内存拷贝。

2.3、发生MinorGC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，则进行一次FullGC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。
#### 3、采用什么方式回收
**标记/清除算法**---原理是当堆中的有效内存空间被耗尽的时候，就会停止整个程序，然后进行两项工作：标记---其实就是遍历所有的GC roots，然后将所有可达的对象标记为存活对象清除---遍历堆中的所有对象，将没有标记的对象全部清除掉。

![](http://i2.muimg.com/595056/505f797aa7ff2b49.png)
![](http://i2.muimg.com/595056/44314108c0017d74.png)
![](http://i2.muimg.com/595056/93bd36a68c4f23e4.png)

缺点: 效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，导致用户体验差、、这种方式清理出来的空闲内存不是连续的。

**复制算法**---将内存划分为两个区间，在任意时间点上，所有动态分配的对象都只能在其中一个区间（称为活动区间），而另一个区间（称为空闲区间）则是空闲的。当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程，会将活动区间内的存活对象全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。空闲区间与活动区间交换的同时，垃圾对象已经被一次性全部回收。不难想象，在下一次GC之后，此时的空闲区间又将变为活动区间，依次循环交替。

![](http://i2.muimg.com/595056/a9a3a5535072ddec.png)
![](http://i2.muimg.com/595056/57bda724a638bc89.png)

复制算法弥补了标记/清除算法中，内存布局混乱的缺点，但它本身缺点也是很明显的:

1、她浪费了一半的内存，这太要命了 

2、复制这项工作所花费的时间，在对象成活率很高的情况下，将变得不可忽视

**标记/整理算法**---也是分两个阶段：
标记：遍历GC roots ，然后将存活的对象标记

整理：移动所有存活的对象，且按照内存地址次序排列，然后将末端内存地址以后的内存全部收回。

![](http://i2.muimg.com/595056/2ae3f1bec6c3a02c.png)
![](http://i2.muimg.com/595056/83f3637abc7d9b48.png)
![](http://i2.muimg.com/595056/6d85eef4ec001654.png)

如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

该算法不仅可以弥补标记/清除算法中内存区域分散的缺点，也消除了复制算法当中内存减半的高额代价，不过它唯一的缺点就是效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。
### Summary
1、三个算法都是基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法的工作的理论依据，就是语法中变量作用域的内容，因此要防止内存泄漏，最根本办法就是掌握好变量作用域。

2、在GC线程开启时，它们都要暂停应用程序（stop the world）

效率：复制 > 整理 > 清除（此处的效率只是简单的对比时间复杂度，实际情况不一定）

内存整齐度： 复制 = 整理 > 清除

内存利用率： 整理 = 清除 > 复制

标记/清除算法是叫落后的了，但其余两种算法都是在清除算法上优化改进而来的

**没有最好的算法，只有更合适的算法**

**分代搜集算法**---针对JAVA堆而设计，也就是针对新生代对象和年老代，而存在于方法区的基本上就是不灭对象，不属于分代搜集算法的内容。

新生代对象---复制算法

年老代对象---标记/整理算法、标记/清除算法

JVM在进行GC时，大部分时候是普通GC（也就是回收的都是新生代），一般情况下，需要经过好几次普通GC，才会触发一次全局GC（针对年老代）。
