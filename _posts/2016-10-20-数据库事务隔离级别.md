---
title: 数据库事务隔离级别
date: 2016-10-20 21:45:52
---
在数据库操作中，为了有效保证并发读取数据的正确性，提出了事务隔离级别的概念

在数据库操作中很可能出现以下不确定情况：

**更新丢失（Lost Update）**：两个事务都同时更新一行数据，但第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。

**脏读（Dirty Reads）**：一个事务开始读取了某行数据，另外一个事务已经更新了此数据但没及时提交。

**不可重复读（Non-repeatable Reads）**：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。比如在两次读取的中途，有另外一个事务对该行数据进行了修改并提交。

**幻读（Phantom Reads）**：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里不要求两次查询的SQL语句相同），这是因为在两次查询过程中有另外一个事务插入数据。

为了避免出现上面几种情况，定义了4种事务隔离级别，不同的隔离级别对事务的处理不同。

**未授权读取，也称为读未提交（Read Uncommitted）**：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则不允许另外一个数据同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

**授权读取，也称为读提交（Read Committed）**：允许不可重复读取，但不允许脏读取。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

**可重复性读取（Repeatable Read）--mysql默认的隔离级别**：禁止不可重复读取和脏读取，但有时可能出现幻影数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

**序列化（Serializable）**：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个的执行，不能并发执行。

![事务隔离级别](http://i2.kiimg.com/595056/dabcb0de993fc078.jpg)

**死锁**---是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种相互等待的现象，如果无外力作用，它们都将无法推进。InnoDB在检测到死锁后，会让一个事务释放锁并回退，另一个事务获得锁，以完成事务。