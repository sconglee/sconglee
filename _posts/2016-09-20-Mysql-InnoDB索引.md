---
title: Mysql-InnoDB索引
date: 2016-09-20 23:30:52
---
**数据库的性能问题**

A: 磁盘IO性能非常低，严重的影响数据库系统的性能

B: 磁盘顺序读写比随机读写的性能高很多

**数据的基本存储结构**

A: 磁盘空间被划分为许多大小相同的块（Black）或者页（Page）

B: 一个表的这些数据块以链表的方式串联在一起

C: 数据是以行（Row）为单位一行一行的存储在磁盘上的块中，如下图

D: 在访问数据时，一次从磁盘中读出或者写入至少一个完整的Block/Page

![分块图](/images/figures/2016-09-20-01.png)

**数据基本操作的实现**

SELECT: 定位数据--> 读出数据所在的块，对数据加工--> 返回数据给用户

UPDATE、DELETE： 定位数据--> 读出数据所在的块，修改数据--> 写回磁盘

INSERT：定位数据要插入的页--＞ 读出要插入的数据页，插入数据--＞ 写回磁盘

**定位数据 How**

从磁盘中依次读出所有的数据块，一行一行的进行数据匹配，直到找到要匹配的数据，时间复杂度是O(n)，如果所有的数据占用了100个块，尽管只查询一行数据，也需要读出所有100个块的数据，这就需要大量的磁盘IO操作，极大的影响了数据定位的性能。数据定位是所有数据操作必须的，所以其效率也会直接影响数据操作的效率

**So 减少磁盘IO How**

A: 减少数据占用的磁盘空间---压缩算法、优化数据存储结构

B: 减少访问数据的总量---读出或写入的数据中，有一部分是数据操作所必须的，这部分称作有效数据，剩余的则是无效数据，例如，查询姓名是张三的记录，那么这条记录是有效记录，其他则是无效记录，我们要努力减少无效数据的访问。

**索引的产生 How**

我们发现多数情况下，定位操作不需要匹配整行数据，而是很规律的只匹配某一个或几个列的值，例如id，把这些确定一条数据的列统称为键（key）。**根据减少无效数据访问的原则，我们只将键的值拿过来存放在独立的块中，并且为每一个键值添加一个指针，指向原来的数据块，这就是索引的祖先**。当进行定位操作时，就不再表扫描，而是进行索引扫描，依次读出所有的索引块，进行键值的匹配，当找到匹配的键值后，根据该行的指针直接读取相应的数据块，进行操作。如下图所示：

![索引产生](/images/figures/2016-09-20-02.png)

**索引的进化**

显然这样的效率还不能满足要求，可以通过排序和查找算法来减少IO
对索引键进行排序，将索引块的地址（以块为单位）和每一个块的第一行的数据存储到数组，在该数组上实现基于块的折半查找，因为其本身是有序的，可以在此基础上再建立索引块，直到最上层只占用一个块为止。

![索引进化](/images/figures/2016-09-20-03.png)

1）这个最上层的Sparse index 称为整个索引树的根root，最底层的数据称为叶子leaf

2）每次进行定位操作时，都从根开始查找，直到叶子节点，才能定位到数据

3）每层索引只需读出一个块

4）索引的IO性能和索引树的高度（索引的层数）成负相关