---
title:  ClassLoader 工作原理与模式
date:   2016-09-18 23:50:45
---
#### ClassLoader what ?
类加载的动态性体现---由于Java程序并不是一个原生的可执行文件，而是由许多独立的类文件组成，每一个文件对应一个java类，而这些类文件并非立即全部装入内存，它总是先把保证程序运行的基础类一次性加载到JVM中，其他类等到JVM用到的时候再加载，这样做节省了内存的开销（因为Java最早是为嵌入式系统设计的，内存宝贵），用时再加载就是Java动态性的体现。而ClassLoader就是负责类文件装入到内存的机制。
#### 体系结构
Java的类装载器实质上也是类，功能是把类载入JVM中，三个类如下：

BootStrap是最顶层的类加载器，用C++语言编写，用来读取Java的核心类库JRE/lib/rt.jar，即系统类

ExtensionClassLoader是用来读取Java的扩展类库JRE/lib/ext/*.jar

AppClassLoader是用来读取classpath指定的所有jar包，即应用类

以上三个装载器存在父子层级关系，从而构成**双亲委托模型**

CustomClassLoader是用户自定义编写的，用来读取指定类文件

#### 类的装载方式
**隐式装载**--程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到JVM中

**显式装载**--通过class.forname()等方法，显示加载需要的类

#### 双亲委托模式
当类装载器有载入类的需求时，会先委托其Parent装载器寻找目标类，如果Parent找不到，那么才由自己依照自己的搜索路径去查找并装载目标类。

使用委托模式也是基于安全来考虑，如果一个恶意的基础类被加载到jvm，会引起严重后果，但使用双亲委托机制，类永远是由根装载器来装载，避免了以上情况的发生。

#### JVM加载class文件的原理机制--加载的详细过程

1、装载

2、链接：检查-->准备-->解析-->初始化
```
graph TD
    A(装载)
    A --> |Ps| F[查找和导入class文件]
    A --> B(检查)
    B --> |Ps| G[检查载入的class文件数据的正确性]
    B --> C(准备)
    C --> |Ps| H[给类的静态变量分配存储空间]
    C --> D(解析)
    D --> |Ps| I[将符号引用转成直接引用]
    D --> E(初始化)
    E --> |Ps| J[对静态变量,静态代码块执行初始化工作]
```
```flow
    st=>start: 装载
    e=>end: 初始化
    op1=>operation: 检查
    op2=>operation: 准备
    op3=>opeartion: 解析
    st->op1->op2->op3->e
```